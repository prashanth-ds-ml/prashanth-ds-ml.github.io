---
title: Aggregations & GROUP BY in SQL

---

#  Blog 2: Mastering Aggregations & GROUP BY in SQL

In [Blog 1](#), we explored basic data profiling ‚Äî `DESCRIBE`, `COUNT`, `DISTINCT`, and null checks. Now we move to the next step: **aggregations**.

SQL aggregation queries help answer questions like:

* What‚Äôs the average sales value?
* How many orders fall in each category?
* What‚Äôs the profit margin by region?

In this blog, we‚Äôll break down **common aggregate functions**, how to use them with `GROUP BY`, and add filters with `HAVING`.

---

## 1. Recap: Aggregate functions

Aggregate functions compute values over multiple rows.
The most commonly used ones are:

| Function   | Use case                              | Example                       |
| ---------- | ------------------------------------- | ----------------------------- |
| `COUNT()`  | Count rows / values                   | Count orders in a segment     |
| `SUM()`    | Total of numeric column               | Total sales per region        |
| `AVG()`    | Average value                         | Average discount per category |
| `MIN()`    | Smallest value                        | Earliest order date           |
| `MAX()`    | Largest value                         | Highest sales transaction     |
| `STDDEV()` | Standard deviation (spread of values) | Variability of sales          |

---

## 2. Summarizing numeric columns

```sql
SELECT
    MIN(sales)    AS min_sales,
    MAX(sales)    AS max_sales,
    AVG(sales)    AS avg_sales,
    STDDEV(sales) AS std_sales
FROM Sales;
```

###  Breakdown

* `MIN(sales)` ‚Üí lowest sales value in the table.
* `MAX(sales)` ‚Üí highest sales value.
* `AVG(sales)` ‚Üí mean sales across all rows.
* `STDDEV(sales)` ‚Üí measures spread/variance.
* `AS` ‚Üí assigns an alias (output column name).

üëâ Pattern to remember:

```sql
SELECT AGG_FUNCTION(column) AS alias
FROM table;
```

---

## 3. Using GROUP BY

`GROUP BY` lets us compute aggregates **per category**.
General pattern:

```sql
SELECT column, AGG_FUNCTION(other_column)
FROM table
GROUP BY column;
```

---

### Example: Orders and sales per segment

```sql
SELECT 
    segment,
    COUNT(order_id)       AS orders,
    SUM(sales)            AS total_sales,
    SUM(profit)           AS total_profit
FROM Sales
GROUP BY segment;
```

###  Breakdown

* `segment` ‚Üí the grouping column.
* `COUNT(order_id)` ‚Üí number of rows per segment.
* `SUM(sales)` ‚Üí total sales for each segment.
* `GROUP BY segment` ‚Üí required whenever you mix aggregates + non-aggregated columns.

üëâ Interview tip: **Every column in SELECT that is not inside an aggregate function must appear in GROUP BY.**

---

## 4. Adding percentages with subqueries

Often we want **% contribution**. We can compute it by dividing group totals by overall totals:

```sql
SELECT 
    segment,
    SUM(sales) AS total_sales,
    ROUND(
      100 * SUM(sales) / (SELECT SUM(sales) FROM Sales), 
      2
    ) AS pct_sales
FROM Sales
GROUP BY segment;
```

###  Breakdown

* `(SELECT SUM(sales) FROM Sales)` ‚Üí scalar subquery returns overall total.
* We divide group-level sum by overall sum, multiply by 100.
* `ROUND(..., 2)` ‚Üí rounds percentage to 2 decimal places.

---

## 5. Aggregating multiple columns

You can group by **multiple dimensions**:

```sql
SELECT 
    region,
    category,
    SUM(sales)  AS total_sales,
    SUM(profit) AS total_profit
FROM Sales
GROUP BY region, category
ORDER BY region, category;
```

### üîç Breakdown

* `GROUP BY region, category` ‚Üí creates combinations (e.g., East‚ÄìTechnology, East‚ÄìFurniture).
* This helps when analyzing cross-sections of the data.

---

## 6. Filtering aggregates with HAVING

Unlike `WHERE` (which filters rows **before aggregation**),
`HAVING` filters **after aggregation**.

```sql
SELECT 
    state,
    SUM(profit) AS total_profit
FROM Sales
GROUP BY state
HAVING SUM(profit) < 0
ORDER BY total_profit ASC;
```

###  Breakdown

* `HAVING SUM(profit) < 0` ‚Üí keeps only states with negative total profit.
* Key difference:

  * `WHERE` ‚Üí row-level filter
  * `HAVING` ‚Üí group-level filter

üëâ Mnemonic:

* **WHERE** = before GROUP BY
* **HAVING** = after GROUP BY

---

## 7. Combining everything

```sql
SELECT 
    category,
    COUNT(order_id)             AS orders,
    SUM(sales)                  AS total_sales,
    SUM(profit)                 AS total_profit,
    ROUND(SUM(profit) / SUM(sales), 2) AS margin,
    AVG(discount)               AS avg_discount
FROM Sales
GROUP BY category
ORDER BY total_sales DESC;
```

### üîç Breakdown

* Multiple aggregates (`COUNT`, `SUM`, `AVG`) in one query.
* Derived metric: profit margin (`SUM(profit)/SUM(sales)`).
* `ORDER BY total_sales DESC` ‚Üí sorts by sales volume.

---

##  Key Patterns to Remember

1. **Basic aggregate**

   ```sql
   SELECT AGG_FUNCTION(column) FROM table;
   ```

2. **Group by one column**

   ```sql
   SELECT col, SUM(num) FROM table GROUP BY col;
   ```

3. **Group by multiple columns**

   ```sql
   SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2;
   ```

4. **Filter after grouping**

   ```sql
   SELECT col, SUM(num) FROM table GROUP BY col HAVING SUM(num) > 1000;
   ```

5. **Add percentages with subqueries**

   ```sql
   SELECT col, 
          SUM(num),
          SUM(num) * 100.0 / (SELECT SUM(num) FROM table) AS pct
   FROM table
   GROUP BY col;
   ```

---

##  Key Points to Remember (for Exams & Interviews)

* **Aggregate Functions**

  * `COUNT(*)` ‚Üí counts rows (NULLs included only with `*`).
  * `SUM(col)` / `AVG(col)` ‚Üí ignores NULLs.
  * `MIN(col)` / `MAX(col)` ‚Üí also ignore NULLs.
  * `STDDEV()` / `VARIANCE()` ‚Üí measure spread.

* **Aliases (`AS`)**

  * Always alias computed columns for clarity.
  * Aliases can be used in `ORDER BY`, but not in `WHERE/HAVING`.

* **GROUP BY Rules**

  * Every non-aggregated column in `SELECT` must appear in `GROUP BY`.
  * You can group by multiple columns ‚Üí creates combinations.
  * You cannot use column aliases in `GROUP BY` (depends on SQL dialect).

* **Difference: WHERE vs HAVING**

  * `WHERE` filters rows **before aggregation**.
  * `HAVING` filters groups **after aggregation**.
  * Common exam trap: trying to use aggregate functions in `WHERE`.

* **ORDER BY with Aggregates**

  * You can sort results on aggregate values (`ORDER BY SUM(sales) DESC`).
  * Aliases are allowed in `ORDER BY`.

* **Percentages with Subqueries**

  * `(SELECT SUM(sales) FROM Sales)` ‚Üí scalar subquery for overall totals.
  * Use it to calculate contribution % in each group.

* **NULL Handling**

  * Aggregates ignore NULLs (except `COUNT(*)`).
  * Use `COALESCE()` to replace NULLs before aggregation if needed.

* **Common Interview Patterns**

  * Top-N queries: `ORDER BY SUM(col) DESC LIMIT N`.
  * Negative totals: `HAVING SUM(profit) < 0`.
  * Ratios/Margins: `SUM(profit) / SUM(sales)`.

---
